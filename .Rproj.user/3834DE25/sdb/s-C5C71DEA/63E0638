{
    "collab_server" : "",
    "contents" : "# Jags-Ymet-Xnom2fac-MrobustHet.R\n# Accompanies the book:\n#  Kruschke, J. K. (2015). Doing Bayesian Data Analysis, Second Edition: \n#  A Tutorial with R, JAGS, and Stan. Academic Press / Elsevier.\n\nsource(\"DBDA2E-utilities.R\")\n\n#===============================================================================\n\ngenMCMC = function( datFrm , yName=\"y\" , x1Name=\"x1\" , x2Name=\"x2\" ,\n                    numSavedSteps=5000 ,  thinSteps=1 , saveName=saveName ,\n                    runjagsMethod=runjagsMethodDefault , \n                    nChains=1 ) { \n  #------------------------------------------------------------------------------\n  # THE DATA.\n  # Convert data file columns to generic x,y variable names for model:\n  y = as.numeric(datFrm[,yName])\n  x1 = as.numeric(as.factor(datFrm[,x1Name]))\n  x1levels = levels(as.factor(datFrm[,x1Name]))\n  x2 = as.numeric(as.factor(datFrm[,x2Name]))\n  x2levels = levels(as.factor(datFrm[,x2Name]))\n  Ntotal = length(y)\n  Nx1Lvl = length(unique(x1))\n  Nx2Lvl = length(unique(x2))\n  # Compute scale properties of data, for passing into prior to make the prior\n  # vague on the scale of the data. \n  # For prior on baseline, etc.:\n  yMean = mean(y)\n  ySD = sd(y)\n  # For prior on deflections:\n  aGammaShRa = unlist( gammaShRaFromModeSD( mode=sd(y)/2 , sd=2*sd(y) ) )\n  # For prior on cell SDs:\n  cellSDs = aggregate( y , list(x1,x2) , FUN=sd )\n  cellSDs = cellSDs[ !is.na(cellSDs$x) ,]\n  medianCellSD = median( cellSDs$x , na.rm=TRUE )\n  sdCellSD = sd( cellSDs$x , na.rm=TRUE )\n  show( paste( \"Median cell SD: \" , medianCellSD ) )\n  show( paste( \"StDev. cell SD: \" , sdCellSD ) )\n  sGammaShRa = unlist( gammaShRaFromModeSD( mode=medianCellSD , sd=2*sdCellSD ) )\n  # Specify the data in a list for sending to JAGS:\n  dataList = list(\n    y = y ,\n    x1 = x1 ,\n    x2 = x2 ,\n    Ntotal = Ntotal ,\n    Nx1Lvl = Nx1Lvl ,\n    Nx2Lvl = Nx2Lvl ,\n    # data properties for scaling the prior:\n    yMean = yMean ,\n    ySD = ySD ,\n    medianCellSD = medianCellSD ,\n    aGammaShRa = aGammaShRa ,\n    sGammaShRa = sGammaShRa\n  )\n  \n  #------------------------------------------------------------------------------\n  # THE MODEL.\n  modelstring = \"\n  model {\n  for ( i in 1:Ntotal ) {\n  y[i] ~ dt( mu[i] , 1/(ySigma[x1[i],x2[i]])^2 , nu )\n  mu[i] <- a0 + a1[x1[i]] + a2[x2[i]] + a1a2[x1[i],x2[i]]\n  }\n  # For sparse data with lots of outliers, there can be multimodal small-nu\n  # estimates, in which case you may want to change the prior to force a \n  # larger value of nu, such as \n  # nu ~ dgamma(5.83,0.0483) # mode 100, sd 50\n  nu ~ dexp(1/30.0) \n  #\n  for ( j1 in 1:Nx1Lvl ) { for ( j2 in 1:Nx2Lvl ) {\n  sigma[j1,j2] ~ dgamma( sigmaSh , sigmaRa )\n  # Prevent from dropping too close to zero:\n  ySigma[j1,j2] <- max( sigma[j1,j2] , medianCellSD/1000 )\n  } }\n  sigmaSh <- 1 + sigmaMode * sigmaRa\n  sigmaRa <- ( sigmaMode + sqrt( sigmaMode^2 + 4*sigmaSD^2 ) ) /(2*sigmaSD^2)\n  sigmaMode ~ dgamma(sGammaShRa[1],sGammaShRa[2]) \n  sigmaSD ~ dgamma(sGammaShRa[1],sGammaShRa[2]) \n  #\n  a0 ~ dnorm( yMean , 1/(ySD*5)^2 ) \n  #\n  for ( j1 in 1:Nx1Lvl ) { a1[j1] ~ dnorm( 0.0 , 1/a1SD^2 ) }\n  a1SD ~ dgamma(aGammaShRa[1],aGammaShRa[2]) \n  #\n  for ( j2 in 1:Nx2Lvl ) { a2[j2] ~ dnorm( 0.0 , 1/a2SD^2 ) }\n  a2SD ~ dgamma(aGammaShRa[1],aGammaShRa[2]) \n  #\n  for ( j1 in 1:Nx1Lvl ) { for ( j2 in 1:Nx2Lvl ) {\n  a1a2[j1,j2] ~ dnorm( 0.0 , 1/a1a2SD^2 )\n  } }\n  a1a2SD ~ dgamma(aGammaShRa[1],aGammaShRa[2]) # or try a folded t (Cauchy)\n  # Convert a0,a1[],a2[],a1a2[,] to sum-to-zero b0,b1[],b2[],b1b2[,] :\n  for ( j1 in 1:Nx1Lvl ) { for ( j2 in 1:Nx2Lvl ) {\n  m[j1,j2] <- a0 + a1[j1] + a2[j2] + a1a2[j1,j2] # cell means \n  } }\n  b0 <- mean( m[1:Nx1Lvl,1:Nx2Lvl] )\n  for ( j1 in 1:Nx1Lvl ) { b1[j1] <- mean( m[j1,1:Nx2Lvl] ) - b0 }\n  for ( j2 in 1:Nx2Lvl ) { b2[j2] <- mean( m[1:Nx1Lvl,j2] ) - b0 }\n  for ( j1 in 1:Nx1Lvl ) { for ( j2 in 1:Nx2Lvl ) {\n  b1b2[j1,j2] <- m[j1,j2] - ( b0 + b1[j1] + b2[j2] )  \n  } }\n  }\n  \" # close quote for modelstring\n  writeLines(modelstring,con=\"TEMPmodel.txt\")\n  #------------------------------------------------------------------------------\n  # INTIALIZE THE CHAINS.\n  # Let JAGS it automatically...\n  #------------------------------------------------------------------------------\n  # RUN THE CHAINS\n  parameters = c( \"b0\" ,  \"b1\" ,  \"b2\" ,  \"b1b2\" , \"m\" , \n                  \"a1SD\" , \"a2SD\" , \"a1a2SD\" ,\n                  \"ySigma\" , \"sigmaMode\" , \"sigmaSD\" , \"nu\" )\n  adaptSteps = 1000 \n  burnInSteps = 500 \n  runJagsOut <- run.jags( method=runjagsMethod ,\n                          model=\"TEMPmodel.txt\" , \n                          monitor=parameters , \n                          data=dataList ,  \n                          #inits=initsList , \n                          n.chains=nChains ,\n                          adapt=adaptSteps ,\n                          burnin=burnInSteps , \n                          sample=ceiling(numSavedSteps/nChains) ,\n                          thin=thinSteps ,\n                          summarise=FALSE ,\n                          plots=FALSE )\n  codaSamples = as.mcmc.list( runJagsOut )\n  \n  # resulting codaSamples object has these indices: \n  #   codaSamples[[ chainIdx ]][ stepIdx , paramIdx ]\n  if ( !is.null(saveName) ) {\n    save( codaSamples , file=paste(saveName,\"Mcmc.Rdata\",sep=\"\") )\n  }\n  return( codaSamples )\n}\n\n#===============================================================================\n\n\nsmryMCMC = function(  codaSamples , \n                      datFrm , x1Name=x1Name , x2Name=x2Name ,\n                      x1contrasts=x1contrasts , x2contrasts=x2contrasts , x1x2contrasts=x1x2contrasts ,\n                      saveName=saveName ) {\n  # All single parameters:\n  parameterNames = varnames(codaSamples) \n  if ( !is.null(datFrm) & !is.null(x1Name) & !is.null(x2Name) ) {\n    x1levels = levels(as.factor(datFrm[,x1Name]))\n    x2levels = levels(as.factor(datFrm[,x2Name]))\n  }\n  summaryInfo = NULL\n  mcmcMat = as.matrix(codaSamples,chains=TRUE)\n  for ( parName in parameterNames ) {\n    summaryInfo = rbind( summaryInfo , summarizePost( mcmcMat[,parName] ) )\n    thisRowName = parName\n    if ( !is.null(datFrm) & !is.null(x1Name) & !is.null(x2Name) ) {\n      # For row name, extract numeric digits from parameter name. E.g., if\n      # parameter name is \"b1b2[12,34]\" then pull out b1b2, 12 and 34:\n      strparts = unlist( strsplit( parName , \"\\\\[|,|\\\\]\"  ) )\n      # if there are only the param name and a single index:\n      if ( length(strparts)==2 ) { \n        # if param name refers to factor 1:\n        if ( substr(strparts[1],nchar(strparts[1]),nchar(strparts[1]))==\"1\" ) { \n          thisRowName = paste( thisRowName , x1levels[as.numeric(strparts[2])] )\n        }\n        # if param name refers to factor 2:\n        if ( substr(strparts[1],nchar(strparts[1]),nchar(strparts[1]))==\"2\" ) { \n          thisRowName = paste( thisRowName , x2levels[as.numeric(strparts[2])] )\n        }\n      }\n      # if there are the param name and two indices:\n      if ( length(strparts)==3 ) { \n        thisRowName = paste( thisRowName , x1levels[as.numeric(strparts[2])], \n                             x2levels[as.numeric(strparts[3])] )\n      }\n    }\n    rownames(summaryInfo)[NROW(summaryInfo)] = thisRowName\n  }\n  # All contrasts:\n  if ( !is.null(x1contrasts) | !is.null(x2contrasts) | !is.null(x1x2contrasts) ) {\n    if ( is.null(datFrm) | is.null(x1Name) | is.null(x2Name) ) {\n      show(\" *** YOU MUST SPECIFY THE DATA FILE AND FACTOR NAMES TO DO CONTRASTS. ***\\n\")\n    } else {\n      x1 = as.numeric(as.factor(datFrm[,x1Name]))\n      x1levels = levels(as.factor(datFrm[,x1Name]))\n      x2 = as.numeric(as.factor(datFrm[,x2Name]))\n      x2levels = levels(as.factor(datFrm[,x2Name]))\n      # x1 contrasts:\n      if ( !is.null(x1contrasts) ) {\n        for ( cIdx in 1:length(x1contrasts) ) {\n          thisContrast = x1contrasts[[cIdx]]\n          left = right = rep(FALSE,length(x1levels))\n          for ( nIdx in 1:length( thisContrast[[1]] ) ) { \n            left = left | x1levels==thisContrast[[1]][nIdx]\n          }\n          left = normalize(left)\n          for ( nIdx in 1:length( thisContrast[[2]] ) ) { \n            right = right | x1levels==thisContrast[[2]][nIdx]\n          }\n          right = normalize(right)\n          contrastCoef = matrix( left-right , ncol=1 )\n          postContrast = ( mcmcMat[,paste(\"b1[\",1:length(x1levels),\"]\",sep=\"\")] \n                           %*% contrastCoef )\n          summaryInfo = rbind( summaryInfo , \n                               summarizePost( postContrast ,\n                                              compVal=thisContrast$compVal ,\n                                              ROPE=thisContrast$ROPE ) )\n          rownames(summaryInfo)[NROW(summaryInfo)] = (\n            paste( paste(thisContrast[[1]],collapse=\"\"), \".v.\",\n                   paste(thisContrast[[2]],collapse=\"\"),sep=\"\") )\n        }\n      }\n      # x2 contrasts:\n      if ( !is.null(x2contrasts) ) {\n        for ( cIdx in 1:length(x2contrasts) ) {\n          thisContrast = x2contrasts[[cIdx]]\n          left = right = rep(FALSE,length(x2levels))\n          for ( nIdx in 1:length( thisContrast[[1]] ) ) { \n            left = left | x2levels==thisContrast[[1]][nIdx]\n          }\n          left = normalize(left)\n          for ( nIdx in 1:length( thisContrast[[2]] ) ) { \n            right = right | x2levels==thisContrast[[2]][nIdx]\n          }\n          right = normalize(right)\n          contrastCoef = matrix( left-right , ncol=1 )\n          postContrast = ( mcmcMat[,paste(\"b2[\",1:length(x2levels),\"]\",sep=\"\")] \n                           %*% contrastCoef )\n          summaryInfo = rbind( summaryInfo , \n                               summarizePost( postContrast ,\n                                              compVal=thisContrast$compVal ,\n                                              ROPE=thisContrast$ROPE ) )\n          rownames(summaryInfo)[NROW(summaryInfo)] = (\n            paste( paste(thisContrast[[1]],collapse=\"\"), \".v.\",\n                   paste(thisContrast[[2]],collapse=\"\"),sep=\"\") )\n        }\n      }\n      # interaction contrasts:\n      if ( !is.null(x1x2contrasts) ) {\n        for ( cIdx in 1:length(x1x2contrasts) ) {\n          thisContrast = x1x2contrasts[[cIdx]]\n          # factor A contrast:\n          facAcontrast = thisContrast[[1]]\n          facAcontrastLeft = facAcontrast[[1]]\n          facAcontrastRight = facAcontrast[[2]]\n          left = right = rep(FALSE,length(x1levels))\n          for ( nIdx in 1:length( facAcontrastLeft ) ) { \n            left = left | x1levels==facAcontrastLeft[nIdx]\n          }\n          left = normalize(left)\n          for ( nIdx in 1:length( facAcontrastRight ) ) { \n            right = right | x1levels==facAcontrastRight[nIdx]\n          }\n          right = normalize(right)\n          facAcontrastCoef = left-right\n          # factor B contrast:\n          facBcontrast = thisContrast[[2]]\n          facBcontrastLeft = facBcontrast[[1]]\n          facBcontrastRight = facBcontrast[[2]]\n          left = right = rep(FALSE,length(x2levels))\n          for ( nIdx in 1:length( facBcontrastLeft ) ) { \n            left = left | x2levels==facBcontrastLeft[nIdx]\n          }\n          left = normalize(left)\n          for ( nIdx in 1:length( facBcontrastRight ) ) { \n            right = right | x2levels==facBcontrastRight[nIdx]\n          }\n          right = normalize(right)\n          facBcontrastCoef = left-right\n          # interaction contrast:\n          contrastCoef = cbind( as.vector( \n            outer( facAcontrastCoef , facBcontrastCoef ) ) )\n          postContrast = ( mcmcMat[,substr(colnames(mcmcMat),1,5)==\"b1b2[\"] \n                           %*% contrastCoef )\n          summaryInfo = rbind( summaryInfo , \n                               summarizePost( postContrast ,\n                                              compVal=thisContrast$compVal ,\n                                              ROPE=thisContrast$ROPE ) )\n          rownames(summaryInfo)[NROW(summaryInfo)] = (\n            paste( paste( paste(thisContrast[[1]][[1]],collapse=\"\"), \n                          \".v.\",\n                          paste(thisContrast[[1]][[2]],collapse=\"\"),sep=\"\"),\n                   \".x.\",\n                   paste( paste(thisContrast[[2]][[1]],collapse=\"\"), \n                          \".v.\",\n                          paste(thisContrast[[2]][[2]],collapse=\"\"),sep=\"\"),\n                   sep=\"\") )\n        }\n      }\n      \n    }\n    \n  }\n  # Save results:\n  if ( !is.null(saveName) ) {\n    write.csv( summaryInfo , file=paste(saveName,\"SummaryInfo.csv\",sep=\"\") )\n  }\n  return( summaryInfo )\n}\n\n#===============================================================================\n\n\nplotMCMC = function( codaSamples , \n                     datFrm, yName=\"y\" , x1Name=x1Name, x2Name=x2Name ,\n                     x1contrasts=x1contrasts , \n                     x2contrasts=x2contrasts , \n                     x1x2contrasts=x1x2contrasts ,\n                     saveName=saveName , saveType=\"jpg\" ) {\n  mcmcMat = as.matrix(codaSamples,chains=TRUE)\n  chainLength = NROW( mcmcMat )\n  y = datFrm[,yName]\n  x1 = as.numeric(as.factor(datFrm[,x1Name]))\n  x1levels = levels(as.factor(datFrm[,x1Name]))\n  x2 = as.numeric(as.factor(datFrm[,x2Name]))\n  x2levels = levels(as.factor(datFrm[,x2Name]))\n  # Display data with posterior predictive distributions\n  for ( x2idx in 1:length(x2levels) ) {\n    openGraph(width=1.2*length(x1levels),height=5)\n    par( mar=c(4,4,2,1) , mgp=c(3,1,0) )\n    plot(-10,-10, \n         xlim=c(0.2,length(x1levels)+0.1) , \n         xlab=paste(x1Name,x2Name,sep=\"\\n\") , \n         xaxt=\"n\" , ylab=yName ,\n         ylim=c(min(y)-0.2*(max(y)-min(y)),max(y)+0.2*(max(y)-min(y))) ,\n         main=\"Data with Post. Pred.\")\n    axis( 1 , at=1:length(x1levels) , tick=FALSE ,\n          lab=paste( x1levels , x2levels[x2idx] , sep=\"\\n\" ) )\n    for ( x1idx in 1:length(x1levels) ) {\n      xPlotVal = x1idx #+ (x2idx-1)*length(x1levels)\n      yVals = y[ x1==x1idx & x2==x2idx ]\n      points( rep(xPlotVal,length(yVals))+runif(length(yVals),-0.05,0.05) , \n              yVals , pch=1 , cex=1.5 , col=\"red\" )\n      chainSub = round(seq(1,chainLength,length=20))\n      for ( chnIdx in chainSub ) {\n        m = mcmcMat[chnIdx,paste0(\"m[\",x1idx,\",\",x2idx,\"]\")]\n        s = mcmcMat[chnIdx,paste0(\"ySigma[\",x1idx,\",\",x2idx,\"]\")]\n        n = mcmcMat[chnIdx,\"nu\"]\n        \n        tlim = qt( c(0.025,0.975) , df=n )\n        yl = m+tlim[1]*s\n        yh = m+tlim[2]*s\n        ycomb=seq(yl,yh,length=201)\n        yt = dt( (ycomb-m)/s , df=n )\n        yt = 0.67*yt/max(yt)\n        lines( xPlotVal-yt , ycomb , col=\"skyblue\" ) \n        \n      }\n    }\n    if ( !is.null(saveName) ) {\n      saveGraph( file=paste0(saveName,\"PostPred-\",x2levels[x2idx]), type=saveType)\n    }\n  } # end for x2idx\n  \n  # Display the normality and top-level variance parameters:\n  openGraph(width=8,height=3)\n  layout( matrix(1:3,nrow=1) )\n  par( mar=c(4,4,2,1) , mgp=c(3,1,0) )\n  compInfo = plotPost( log10(mcmcMat[,\"nu\"]) , xlab=expression(\"log10(\"*nu*\")\") ,\n                       main=\"Normality\", compVal=NULL , ROPE=NULL )\n  compInfo = plotPost( mcmcMat[,\"sigmaMode\"] , xlab=\"param. value\" ,\n                       main=\"Mode of Cell Sigma's\", compVal=NULL , ROPE=NULL )\n  compInfo = plotPost( mcmcMat[,\"sigmaSD\"] , xlab=\"param. value\" ,\n                       main=\"SD of Cell Sigma's\", compVal=NULL , ROPE=NULL )\n  if ( !is.null(saveName) ) {\n    saveGraph( file=paste0(saveName,\"NuSigmaMode\"), type=saveType)\n  }\n  \n  # plot contrasts:\n  if ( !is.null(x1contrasts) | !is.null(x2contrasts) | !is.null(x1x2contrasts) ) {\n    if ( is.null(datFrm) | is.null(x1Name) | is.null(x2Name) ) {\n      show(\" *** YOU MUST SPECIFY THE DATA FILE AND FACTOR NAMES TO DO CONTRASTS. ***\\n\")\n    } else {\n      x1 = as.numeric(as.factor(datFrm[,x1Name]))\n      x1levels = levels(as.factor(datFrm[,x1Name]))\n      x2 = as.numeric(as.factor(datFrm[,x2Name]))\n      x2levels = levels(as.factor(datFrm[,x2Name]))\n      # x1 contrasts:\n      if ( !is.null(x1contrasts) ) {\n        for ( cIdx in 1:length(x1contrasts) ) {\n          thisContrast = x1contrasts[[cIdx]]\n          left = right = rep(FALSE,length(x1levels))\n          for ( nIdx in 1:length( thisContrast[[1]] ) ) { \n            left = left | x1levels==thisContrast[[1]][nIdx]\n          }\n          left = normalize(left)\n          for ( nIdx in 1:length( thisContrast[[2]] ) ) { \n            right = right | x1levels==thisContrast[[2]][nIdx]\n          }\n          right = normalize(right)\n          contrastCoef = matrix( left-right , ncol=1 )\n          postContrast = ( mcmcMat[,paste(\"b1[\",1:length(x1levels),\"]\",sep=\"\")] \n                           %*% contrastCoef )\n          openGraph(height=4,width=4)\n          compInfo = plotPost( postContrast , xlab=\"Difference\" ,\n                               main=paste0( \n                                 paste(thisContrast[[1]],collapse=\".\"), \n                                 \"\\nvs\\n\",\n                                 paste(thisContrast[[2]],collapse=\".\") ),\n                               compVal=thisContrast$compVal ,\n                               ROPE=thisContrast$ROPE )\n          saveGraph(file=paste0(saveName,\n                                paste(thisContrast[[1]],collapse=\".\"), \n                                \"-vs-\",\n                                paste(thisContrast[[2]],collapse=\".\")),\n                    type=graphFileType)\n        }\n      }\n      # x2 contrasts:\n      if ( !is.null(x2contrasts) ) {\n        for ( cIdx in 1:length(x2contrasts) ) {\n          thisContrast = x2contrasts[[cIdx]]\n          left = right = rep(FALSE,length(x2levels))\n          for ( nIdx in 1:length( thisContrast[[1]] ) ) { \n            left = left | x2levels==thisContrast[[1]][nIdx]\n          }\n          left = normalize(left)\n          for ( nIdx in 1:length( thisContrast[[2]] ) ) { \n            right = right | x2levels==thisContrast[[2]][nIdx]\n          }\n          right = normalize(right)\n          contrastCoef = matrix( left-right , ncol=1 )\n          postContrast = ( mcmcMat[,paste(\"b2[\",1:length(x2levels),\"]\",sep=\"\")] \n                           %*% contrastCoef )\n          openGraph(height=4,width=4)\n          compInfo = plotPost( postContrast , xlab=\"Difference\" ,\n                               main=paste0( \n                                 paste(thisContrast[[1]],collapse=\".\"), \n                                 \"\\nvs\\n\",\n                                 paste(thisContrast[[2]],collapse=\".\") ),\n                               compVal=thisContrast$compVal ,\n                               ROPE=thisContrast$ROPE )\n          saveGraph(file=paste0(saveName,\n                                paste(thisContrast[[1]],collapse=\".\"), \n                                \"-vs-\",\n                                paste(thisContrast[[2]],collapse=\".\")),\n                    type=graphFileType)\n        }\n      }\n      # interaction contrasts:\n      if ( !is.null(x1x2contrasts) ) {\n        for ( cIdx in 1:length(x1x2contrasts) ) {\n          thisContrast = x1x2contrasts[[cIdx]]\n          # factor A contrast:\n          facAcontrast = thisContrast[[1]]\n          facAcontrastLeft = facAcontrast[[1]]\n          facAcontrastRight = facAcontrast[[2]]\n          left = right = rep(FALSE,length(x1levels))\n          for ( nIdx in 1:length( facAcontrastLeft ) ) { \n            left = left | x1levels==facAcontrastLeft[nIdx]\n          }\n          left = normalize(left)\n          for ( nIdx in 1:length( facAcontrastRight ) ) { \n            right = right | x1levels==facAcontrastRight[nIdx]\n          }\n          right = normalize(right)\n          facAcontrastCoef = left-right\n          # factor B contrast:\n          facBcontrast = thisContrast[[2]]\n          facBcontrastLeft = facBcontrast[[1]]\n          facBcontrastRight = facBcontrast[[2]]\n          left = right = rep(FALSE,length(x2levels))\n          for ( nIdx in 1:length( facBcontrastLeft ) ) { \n            left = left | x2levels==facBcontrastLeft[nIdx]\n          }\n          left = normalize(left)\n          for ( nIdx in 1:length( facBcontrastRight ) ) { \n            right = right | x2levels==facBcontrastRight[nIdx]\n          }\n          right = normalize(right)\n          facBcontrastCoef = left-right\n          # interaction contrast:\n          contrastCoef = cbind( as.vector( \n            outer( facAcontrastCoef , facBcontrastCoef ) ) )\n          postContrast = ( mcmcMat[,substr(colnames(mcmcMat),1,5)==\"b1b2[\"] \n                           %*% contrastCoef )\n          mainName = paste0(\n            paste0(paste(thisContrast[[1]][[1]],collapse=\".\"), \n                   \".v.\",\n                   paste(thisContrast[[1]][[2]],collapse=\".\")),\n            \"\\n(x)\\n\",\n            paste0(paste(thisContrast[[2]][[1]],collapse=\".\"), \n                   \".v.\",\n                   paste(thisContrast[[2]][[2]],collapse=\".\")))\n          openGraph(height=4,width=4)\n          compInfo = plotPost( postContrast , xlab=\"Difference of Differences\" ,\n                               main=mainName ,\n                               compVal=thisContrast$compVal ,\n                               ROPE=thisContrast$ROPE )\n          fileNameSuffix = paste0(\n            paste0(paste(thisContrast[[1]][[1]],collapse=\".\"), \n                   \".v.\",\n                   paste(thisContrast[[1]][[2]],collapse=\".\")),\n            \"(x)\",\n            paste0(paste(thisContrast[[2]][[1]],collapse=\".\"), \n                   \".v.\",\n                   paste(thisContrast[[2]][[2]],collapse=\".\")))\n          saveGraph(file=paste0(saveName,fileNameSuffix),\n                    type=graphFileType)\n        }\n      } # end of interaction contrasts\n    }  \n  } # end plot contrasts\n}\n\n\n# #==============================================================================\n# # Do NHST ANOVA:\n# \n# theData = data.frame( y=y , x1=factor(x1,labels=x1levels) ,\n#                             x2=factor(x2,labels=x2levels) )\n# openGraph(width=7,height=7)\n# interaction.plot( theData$x1 , theData$x2 , theData$y , type=\"b\" )\n# #saveGraph( file=paste(saveName,\"DataPlot\",sep=\"\") , type=\"eps\" )\n# aovresult = aov( y ~ x1 * x2 , data = theData )\n# cat(\"\\n------------------------------------------------------------------\\n\\n\")\n# print( summary( aovresult ) )\n# cat(\"\\n------------------------------------------------------------------\\n\\n\")\n# print( model.tables( aovresult , type = \"effects\", se = TRUE ) , digits=3 )\n# cat(\"\\n------------------------------------------------------------------\\n\\n\")\n# \n# #==============================================================================",
    "created" : 1538542635605.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2969552914",
    "id" : "63E0638",
    "lastKnownWriteTime" : 1538559147,
    "last_content_update" : 1538559147777,
    "path" : "~/RMIT/2018 RMIT SEM 2/Applied Bayesian Statistics/Course Project/Bayesian.Course.Proj/Jags-Ymet-Xnom2fac-MrobustHet.Assn3.R",
    "project_path" : "Jags-Ymet-Xnom2fac-MrobustHet.Assn3.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}